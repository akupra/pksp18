#include <iostream>
using namespace std;

struct TreeElement
{
    int value;
    TreeElement* right;
    TreeElement* left;

    TreeElement()
    {
        value = -1;
        right = NULL;
        left = NULL;
    }
};

inline void Input(TreeElement*& el, int v)
{
    if (el == NULL)
    {
        el = new TreeElement();
        el->value = v;
    }
    else if (el->value > v)
    {
        Input(el->left, v);
    }
    else if (el->value < v)
    {
        Input(el->right, v);
    }
}
inline void Output(TreeElement* el)
{
	if (el != NULL)
	{
		//cout << "(";
		Output(el->left);
		cout << el->value << " ";
		Output(el->right);
		//cout << ")";
	}
	/*else
	{
		cout << ".";
	}*/
}

inline void Detach(TreeElement* root, TreeElement* el)
{
	/*
	Данную функцию следует вызывать перед удалением поддерева el из дерева root
	Поскольку элемент не хранит в себе ссылку на родительский корень, а хранит только ссылки на левое и правое поддеревья,
	удаление элемента приведет к тому, что в одной из веток родительского корня появится "битая" ссылка. Т.е. в указателе хранится адрес на элемент,
	который уже был удален и которого уже нет. Чтобы избежать этого данная функция ищет удаляемый элемент, а при нажождении обнуляет на него ссылку.
	*/
	if (root == NULL || el == NULL) { return; } //проверять нечего, т.к. один из указателей указывает в никуда. (т.е. либо нет удаляемого эелемента, либо нет корня)
	else if (root->left == el) { root->left = NULL; } //будет удаляться левое поддерево текущего корня. обнулили левую ссылку
	else if (root->right == el) { root->right = NULL; } //будет удаляться правое поддерево текущего корня. обнулили правую ссылку
	{
		//удаляемый элемент все еще не найден
		Detach(root->left, el); //ищем слева
		Detach(root->right, el); //ищем справа
	}
}
inline void Remove(TreeElement* el)
{
	/*
	Данная функция НЕ ищет поддерево, которое нужно удалить!
	Она удаляет заранее найденное поддерево, которое ей передали при вызове.
	Если требуется удалить определенное поддерево из дерева, предварительно его необходимо найти (для этого должен быть другой код),
	а затем вызвать эту функцию.
	*/
	if (el != NULL)
	{
		Remove(el->left); //удаляем левое поддерево пришедшего в функцию корня
		Remove(el->right); //удаляем правое поддерево пришедшего в функцию корня
		delete el; //удаляем корень
	}
}
inline TreeElement* Find(TreeElement* el, int v)
{
	/*
	Функция будет искать в дереве корень, значение которого равно v
	Первоначально в фунцию передется корень дерева. Далее она анализирует этот корень на равенство v.
	Если равно, поиск заврешен. Запоминаем указатель в перемнную result и возвращаемся из функции.
	Если не равно, то функция рекурсивно себя вызывает снаала для левого поддерева, передавая в вызов указатель на левое поддерево и переменную v.
	Если в левом поддереве значение найдется, но запоминаем его и выходим из функции. Если не найдется, то функция будет его искать в правом поддереве.
	В процессе рекурсивного спука по дереву функция так или иначе найдет ворень, значение которого равно v (если таковой в дереве имеется).
	*/
	TreeElement* result = NULL;
	if (el == NULL) { result = NULL; }	//проверять нечего, т.к. указатель указывает в никуда.
	else if (el->value == v) { result = el; } //значение нашлось
	else
	{
		result = Find(el->left, v); //ищем в левом поддереве
		if (result == NULL) { result = Find(el->right, v); } //если слева не нашли, ищем в правом поддереве
	}
	return result;
}

inline int Sum(TreeElement* el)
{
	/*
	Данныя функция найдет сумму элементов в поддереве, на которое ссылает el.
	Сначала она посчитает сумму для левого поддерева (el->left).
	Потом она посчитает сумму для правого поддерева (el->rigth).
	Далее она сложит две найденные суммы между собой и прибавит к ним значение элемента,
	которое хранится в el->value

	Возможная ошибка: поиск суммы в el, в то время, как el == NULL.
	Чтобы ее избежать, вводится простая соответствующая проверка.
	Если проверка не пройдена, то функция вернет 0.
	*/
	if (el != NULL)
	{
		int l = Sum(el->left); //сумма для левого поддерева
		int r = Sum(el->right); //сумма для правого поддерева

		return l + r + el->value;
	}
	else
	{
		return 0;
	}
}